.ADS.BATCAP
ADS.c:426:    sprintf(ADS.BATCAP, "%7.2f", floater);
ADS.c:517:  strncpy(ADS.BATCAP, p ? p : BATTERYCAPACITY_DEFAULT, sizeof(ADS.BATCAP));
.ADS.BATLOG
ADS.c:522:  ADS.BATLOG = atoi(p ? p : BATTERYLOGGER_DEFAULT);
MPC.c:1184:          ADS.BATLOG = value;
.ADS.MINVOLT
ADS.c:508:  strncpy(ADS.MINVOLT, p ? p : MINSYSVOLT_DEFAULT, sizeof(ADS.MINVOLT));
ADS.c:512:    sprintf(ADS.MINVOLT, "%5.2f", MIN_BATTERY_VOLTAGE);
MPC.c:1174:        sprintf(ADS.MINVOLT, "%4.2f", floatvalue);
.AMDM.MAXUPL
MPC.c:1221:        AMDM.MAXUPL = value;
.AVG.VEL
.BIOSGVT.BIOSVersion
.BIOSGVT.CF1SerNum
.BIOSGVT.CFxSerNum
.BIOSGVT.PICOVersion
.BT.ON
MPC.c:1098:        BT.ON = value;
.CTD.UPLOAD
CTD.c:548:  CTD.UPLOAD = atoi(p ? p : CTDUPLOADFILE_DEFAULT);
MPC.c:1004:          CTD.UPLOAD = value;
.IRID.ANTSW
GPSIRID.c:1957:  IRID.ANTSW = atoi(p ? p : ANTSW_DEFAULT);
.IRID.CALLHOUR
GPSIRID.c:1986:  IRID.CALLHOUR = atoi(p ? p : CALLHOUR_DEFAULT);
LARA.c:1526:    IRID.CALLHOUR = hours;
LARA.c:1528:      IRID.CALLHOUR = 23;
LARA.c:1530:      IRID.CALLHOUR = 0;
MPC.c:1112:        IRID.CALLHOUR = value;
.IRID.CALLMODE
GPSIRID.c:1990:  IRID.CALLMODE = atoi(p ? p : CALLMODE_DEFAULT);
LARA.c:390:    IRID.CALLMODE = 1;
MPC.c:1124:          IRID.CALLMODE = value;
.IRID.LOWFIRST
.IRID.MAXCALLS
GPSIRID.c:1974:  IRID.MAXCALLS = atoi(p ? p : MAXCALLS_DEFAULT);
.IRID.MAXUPL
GPSIRID.c:1953:  IRID.MAXUPL = atoi(p ? p : MAXUPLOAD_DEFAULT);
MPC.c:1215:        IRID.MAXUPL = value;
.IRID.MINSIGQ
GPSIRID.c:1966:  IRID.MINSIGQ = atoi(p ? p : MINSIGQ_DEFAULT);
.IRID.OFFSET
GPSIRID.c:1978:  IRID.OFFSET = atoi(p ? p : OFFSET_DEFAULT);
.IRID.PHONE
GPSIRID.c:1962:  strncpy(IRID.PHONE, p ? p : IRIDPHONE_DEFAULT, sizeof(IRID.PHONE));
.IRID.REST
GPSIRID.c:1982:  IRID.REST = atoi(p ? p : IRIDREST_DEFAULT);
.IRID.WARMUP
GPSIRID.c:1970:  IRID.WARMUP = atoi(p ? p : WARMUP_DEFAULT);
.LARA.ASCENTTIME
LARA.c:345:  LARA.ASCENTTIME = -1;
.LARA.AVGVEL
LARA.c:288:  LARA.AVGVEL = 0;
LARA.c:605:      LARA.AVGVEL = CTD_CalculateVelocity();
LARA.c:607:        LARA.AVGVEL = ((float)NIGK.RRATE / 60.0);
.LARA.BUOYMODE
CTD.c:591:      LARA.BUOYMODE=0;
CTD.c:594:      if (vel>0) LARA.BUOYMODE=1;
CTD.c:595:      else LARA.BUOYMODE=2;
LARA.c:282:  LARA.BUOYMODE = 0;     // Also Decided Below
LARA.c:355:    LARA.BUOYMODE = 0;
LARA.c:402:        LARA.BUOYMODE = 1;
LARA.c:407:        LARA.BUOYMODE = 2;
LARA.c:413:        LARA.BUOYMODE = 0;
Winch.c:111:    LARA.BUOYMODE = 1;
Winch.c:119:    LARA.BUOYMODE = 2;
Winch.c:148:    LARA.BUOYMODE = 0;
.LARA.CTDSAMPLES
CTD.c:508:  LARA.CTDSAMPLES++;
LARA.c:349:  LARA.CTDSAMPLES = 0;
.LARA.DATA
LARA.c:26:*    case '2': LARA.DATA = LARA.DATA ? false : true;
LARA.c:31:*    case 'x': LARA.ON = false; LARA.DATA = LARA.DATA ? false : true;
LARA.c:280:  LARA.DATA = false;
LARA.c:512:      LARA.DATA = true;
LARA.c:553:    LARA.DATA = false;
LARA.c:733:  LARA.DATA = false;
LARA.c:834:  LARA.DATA = false;
LARA.c:1067:      LARA.DATA = LARA.DATA ? false : true;
.LARA.DEPTH
CTD.c:436:  LARA.DEPTH = pres;
LARA.c:284:  LARA.DEPTH = 0;        // Received from first CTD
LARA.c:548:  LARA.DEPTH = CTD_AverageDepth(9, &velocity);
LARA.c:858:  LARA.DEPTH=0.0;
.LARA.DESCENTTIME
LARA.c:346:  LARA.DESCENTTIME = -1;
LARA.c:823:  LARA.DESCENTTIME = (short)(DescentStop - DescentStart);
.LARA.LOWPOWER
LARA.c:337:    LARA.LOWPOWER = true;
LARA.c:339:    LARA.LOWPOWER = false;
.LARA.MOORDEPTH
LARA.c:285:  LARA.MOORDEPTH = 0;    // Eventually init
LARA.c:414:        LARA.MOORDEPTH = LARA.DEPTH;
LARA.c:552:    LARA.MOORDEPTH = LARA.DEPTH;
LARA.c:814:    LARA.MOORDEPTH = LARA.DEPTH;
.LARA.ON
LARA.c:25:*    case 'x': LARA.ON = false;
LARA.c:31:*    case 'x': LARA.ON = false; LARA.DATA = LARA.DATA ? false : true;
LARA.c:35:*    case 'x': LARA.ON = false; // exit from GPSIRID
LARA.c:281:  LARA.ON = true;
LARA.c:458:  LARA.ON = true;
.LARA.PAYOUT
LARA.c:344:  LARA.PAYOUT = -1;
LARA.c:616:  LARA.PAYOUT = ((float)LARA.ASCENTTIME / 60.0) * NIGK.RRATE;
.LARA.PHASE
LARA.c:24:*    case 'p': LARA.PHASE = c;
LARA.c:29:*    case 'p': LARA.PHASE = c;
LARA.c:36:*    case 'p': LARA.PHASE = c;
LARA.c:279:  LARA.PHASE = 0; // Decided Below
LARA.c:356:    LARA.PHASE = 5; // deploy phase
LARA.c:377:    LARA.PHASE = 0; // Phase 0 when finding the winch status and ctd position as
LARA.c:403:        LARA.PHASE = 2;
LARA.c:406:        LARA.PHASE = 4;
LARA.c:412:        LARA.PHASE = 1;
LARA.c:427:          LARA.PHASE = 3;
LARA.c:429:          LARA.PHASE = 4;
LARA.c:431:        LARA.PHASE = 4;
LARA.c:437:      LARA.PHASE = 1;
LARA.c:524:    LARA.PHASE = 3;
LARA.c:526:    LARA.PHASE = 2;
LARA.c:563:    LARA.PHASE = 3;
LARA.c:624:    LARA.PHASE = 3;
LARA.c:675:      LARA.PHASE = 4;
LARA.c:700:      LARA.PHASE = 4;
LARA.c:717:  if (NIGK.RECOVERY) LARA.PHASE = 1; 
LARA.c:833:  LARA.PHASE = 1;
LARA.c:893:  LARA.PHASE=2;
LARA.c:1021:  switch (LARA.PHASE) {
LARA.c:1058:      LARA.PHASE = c;
LARA.c:1083:      LARA.PHASE = c;
LARA.c:1116:      LARA.PHASE = c;
Winch.c:142:          LARA.PHASE++;
.LARA.STATUS
LARA.c:347:  LARA.STATUS = -1;
.LARA.SURFACED
LARA.c:33:*    case 's': LARA.SURFACED = true;
LARA.c:283:  LARA.SURFACED = false; // Decided Below
LARA.c:357:    LARA.SURFACED = false;
LARA.c:398:      LARA.SURFACED = false;
LARA.c:422:      LARA.SURFACED = true;
LARA.c:562:    LARA.SURFACED = true;
LARA.c:603:        LARA.SURFACED = true;
LARA.c:751:  LARA.SURFACED = false;
LARA.c:1101:      LARA.SURFACED = true;
Winch.c:143:          LARA.SURFACED = true;
.LARA.SWITCH
.LARA.TDEPTH
LARA.c:287:  LARA.TDEPTH = 0;       // Decided from Param file
LARA.c:440:  LARA.TDEPTH = NIGK.TDEPTH;
LARA.c:726:  LARA.TDEPTH = NIGK.TDEPTH;
.LARA.TEMP
.LARA.TOPDEPTH
LARA.c:286:  LARA.TOPDEPTH = 0; // depth at start of descent // Eventually Init
LARA.c:561:    LARA.TOPDEPTH = LARA.DEPTH;
LARA.c:600:      LARA.TOPDEPTH = LARA.DEPTH;
LARA.c:769:    LARA.TOPDEPTH = LARA.DEPTH;
.MPC.DATAXINT
LARA.c:454:    MPC.DATAXINT = 30;
MPC.c:409:          MPC.DATAXINT = 30;
MPC.c:470:  MPC.DATAXINT += MPC.DETINT;
MPC.c:511:  MPC.DATAXINT -= MPC.DETINT;
MPC.c:1141:        MPC.DATAXINT = value;
MPC.c:1312:  MPC.DATAXINT = atoi(p ? p : DATAXINTERVAL_DEFAULT);
MPC.c:1315:    MPC.DATAXINT = MIN_DATAX_INTERVAL;
MPC.c:1318:    MPC.DATAXINT = MAX_DATAX_INTERVAL;
.MPC.DETINT
MPC.c:469:  MPC.DETINT += 5;
MPC.c:512:  MPC.DETINT -= 5;
MPC.c:1159:        MPC.DETINT = value;
MPC.c:1300:  MPC.DETINT = atoi(p ? p : DETECTIONINT_DEFAULT);
MPC.c:1303:    MPC.DETINT = MIN_DETECTION_INTERVAL;
MPC.c:1306:    MPC.DETINT = MAX_DETECTION_INTERVAL;
.MPC.FILENUM
LARA.c:304:    MPC.FILENUM--;
LARA.c:312:    MPC.FILENUM++;
LARA.c:721:  MPC.FILENUM++;
MPC.c:175:  MPC.FILENUM = counter + 1;
.MPC.HIBERNATE
MPC.c:1323:MPC.HIBERNATE = atoi( p ? p : HIBERNATE_DEFAULT);
.MPC.LAT
GPSIRID.c:523:    strncpy(MPC.LAT, Coordinates, 16);
MPC.c:1272:  strncpy(MPC.LAT, p ? p : LATITUDE_DEFAULT, sizeof(MPC.LAT));
.MPC.LOCATION
MPC.c:1276:          strncpy(MPC.LOCATION, p ? p : LOCATION_DEFAULT, sizeof(MPC.LOCATION));
.MPC.LOGFILE
MPC.c:181:  strncpy(MPC.LOGFILE, p ? p : LOGFILE_DEFAULT, sizeof(MPC.LOGFILE));
.MPC.LONG
GPSIRID.c:525:    strncpy(MPC.LONG, &Coordinates[17], 16);
MPC.c:1268:  strncpy(MPC.LONG, p ? p : LONGITUDE_DEFAULT, sizeof(MPC.LONG));
.MPC.MINVOLT
.MPC.PLTFRMID
MPC.c:1264:  strncpy(MPC.PLTFRMID, p ? p : PLTFRMID_DEFAULT, sizeof(MPC.PLTFRMID));
.MPC.PROGNAME
MPC.c:1256:  strncpy(MPC.PROGNAME, p ? p : PROG_DEFAULT, sizeof(MPC.PROGNAME));
.MPC.PROJID
MPC.c:1260:  strncpy(MPC.PROJID, p ? p : PROJID_DEFAULT, sizeof(MPC.PROJID));
.MPC.STARTMAX
MPC.c:1200:        MPC.STARTMAX = value;
MPC.c:1286:  MPC.STARTMAX = atoi(p ? p : STARTMAX_DEFAULT);
MPC.c:1290:    MPC.STARTMAX = MAX_STARTUPS;
.MPC.STARTUPS
LARA.c:443:  MPC.STARTUPS++;
MPC.c:1281:  MPC.STARTUPS = atoi(p ? p : STARTUPS_DEFAULT);
.MPC.UPLOAD
.NIGK.ANTLEN
Winch.c:276:  NIGK.ANTLEN = atoi(p ? p : NIGKANTENNALENGTH_DEFAULT);
.NIGK.DELAY
Winch.c:272:  NIGK.DELAY = atoi(p ? p : NIGKDELAY_DEFAULT);
.NIGK.FRATE
MPC.c:1047:        NIGK.FRATE = value;
Winch.c:290:  NIGK.FRATE = atoi(p ? p : NIGKFALLRATE_DEFAULT);
.NIGK.PROFILES
LARA.c:574:  NIGK.PROFILES++;
Winch.c:294:  NIGK.PROFILES = atoi(p ? p : NIGKPROFILES_DEFAULT);
.NIGK.RECOVERY
MPC.c:405:        NIGK.RECOVERY = 1;
MPC.c:1057:          NIGK.RECOVERY = value;
Winch.c:299:  NIGK.RECOVERY = atoi(p ? p : NIGKRECOVERY_DEFAULT);
.NIGK.RRATE
MPC.c:1034:        NIGK.RRATE = value;
Winch.c:286:  NIGK.RRATE = atoi(p ? p : NIGKRISERATE_DEFAULT);
.NIGK.TDEPTH
MPC.c:1021:        NIGK.TDEPTH = value;
Winch.c:281:  NIGK.TDEPTH = atoi(p ? p : NIGKTARGETDEPTH_DEFAULT);
.SEAG.DIVENUM
.SEAG.OFFDEPTH
MPC.c:1071:        SEAG.OFFDEPTH = value;
.SEAG.ONDEPTH
MPC.c:1083:        SEAG.ONDEPTH = value;
.WINCH.ASCENTCALLS
LARA.c:270:  WINCH.ASCENTCALLS = 0;
Winch.c:170:  WINCH.ASCENTCALLS++;
Winch.c:327:  WINCH.ASCENTCALLS = 0;
.WINCH.ASCENTRCV
LARA.c:271:  WINCH.ASCENTRCV = 0;
Winch.c:112:    WINCH.ASCENTRCV++;
Winch.c:328:  WINCH.ASCENTRCV = 0;
.WINCH.BUOYRCV
LARA.c:276:  WINCH.BUOYRCV = 0;
Winch.c:225:  WINCH.BUOYRCV++;
Winch.c:333:  WINCH.BUOYRCV = 0;
.WINCH.DESCENTCALLS
LARA.c:272:  WINCH.DESCENTCALLS = 0;
Winch.c:182:  WINCH.DESCENTCALLS++;
Winch.c:329:  WINCH.DESCENTCALLS = 0;
.WINCH.DESCENTRCV
LARA.c:273:  WINCH.DESCENTRCV = 0;
Winch.c:120:    WINCH.DESCENTRCV++;
Winch.c:330:  WINCH.DESCENTRCV = 0;
.WINCH.STOPCALLS
LARA.c:274:  WINCH.STOPCALLS = 0;
Winch.c:199:  WINCH.STOPCALLS++;
Winch.c:331:  WINCH.STOPCALLS = 0;
.WINCH.STOPRCV
LARA.c:275:  WINCH.STOPRCV = 0;
Winch.c:125:      WINCH.STOPRCV++;
Winch.c:332:  WINCH.STOPRCV = 0;
.WINCH.WINCHCALLS
LARA.c:277:  WINCH.WINCHCALLS = 0;
Winch.c:334:  WINCH.WINCHCALLS = 0;
.WISP.DETMAX
MPC.c:960:        WISP.DETMAX = value;
WISPR.c:522:  WISP.DETMAX = atoi(p ? p : DETECTIONMAX_DEFAULT);
WISPR.c:525:    WISP.DETMAX = MAX_DETECTIONS;
.WISP.DETNUM
MPC.c:970:               WISP.DETNUM=value;
WISPR.c:543:  WISP.DETNUM = atoi(p ? p : DETECTIONNUM_DEFAULT);
.WISP.DUTYCYCL
LARA.c:327:    WISP.DUTYCYCL = 0; // Booting up with default.cfg will never have a set
MPC.c:983:        WISP.DUTYCYCL = value;
WISPR.c:163:        WISP.DUTYCYCL = 0;
WISPR.c:548:  WISP.DUTYCYCL = atoi(p ? p : DUTYCYCLE_DEFAULT);
WISPR.c:552:    WISP.DUTYCYCL = MAX_DUTYCYCLE;
WISPR.c:555:    WISP.DUTYCYCL = MIN_DUTYCYCLE;
.WISP.GAIN
MPC.c:947:        WISP.GAIN = value;
WISPR.c:531:  WISP.GAIN = atoi(p ? p : WISPRGAIN_DEFAULT);
WISPR.c:534:    WISP.GAIN = 3;
WISPR.c:537:    WISP.GAIN = 0;
.WISP.NUM
LARA.c:363:        WISP.NUM = 1; // current used board
MPC.c:993:        WISP.NUM = value;
WISPR.c:511:  WISP.NUM = wnum;
WISPR.c:561:  WISP.NUM = atoi(p ? p : WISPRNUM_DEFAULT);
WISPR.c:564:    WISP.NUM = 1;
WISPR.c:567:    WISP.NUM = WISPRNUMBER;
WISPR.c:787:  WISP.NUM = wnum;
WISPR.c:828:    WISP.NUM = WISPRNUMBER;
