/******************************************************************************\** Rev 3.4 (6/11/2016)** To prevent from rebooting while checking free space in a large CF card (e.g., 512 GB)** added PIT chore. TickleSWSR is issued at 13 sec interval.    ** 1. BIRCurrentSetup(short *BIACardNum, short *BIADevice, char *Drive) is added to** report the current CFDOSDRV(). ** 2. Bug at line 455: execstr(mounte)->execstr(mountd);//mount master as d: (7/27/2015)** 3. Bug in BIRCFSlaveToMaster (line 867). Specify the correct drive letter for **    next drive mount.** 4. Bug in BIRIncVolumeVars() (line 503). It was shutting down the new volume (CURBIA).** 5. Added the new disk capacity print statement in BIRIncVolumeVars() (line 709).**	6. Drive name changes depending on which CURBIA it is on**    CURBIA	0  1	2	3	4  **		Master	D	F	H	K	L**		Slave		E	G	I	J	M**		You can use SYS.F32TRUST=* PicoDOS option, which makes the free space search**		fast.  But you have to mount each drive with drive letter and do 'DIR' before**		launching the program. For example**			mount F: bfcm-1 and dir**			mount G: bfcs-1 and dir**			mount H: bfcm-2 and dir etc**  **		You can use large CF cards (>=512GB).**** Rev 3.1 BIRCFRecorder2.c (01/31/2014) HM** Previous version CF2LogSP3i3_2 with BIRCFRecorder.c uses 20 mA more on the ** slave drive.  The new one, with BIRCFRecorder2.c reduces the current by mounting ** both D: and E: (master and slave drives).  Uses execstr("mount .. ) command.**** For BigIDEA multiple CF cards data logger. It logs the data on master and slave** ports per BIA adopter as D: drive.  If the drive has only master, it** logs only on master. No longer uses a ping-pong buffer, therefore no need to ** create ram drive in C:.  Slave drive uses 20mA more current, so choose a small** CF card for slave and much larger size card for the master. ** ** Rev 2.1** MaxOnTimeout is now 12 minutes (3/01/2004 HM)to accomodate the larger CF. HM**	FAT32_NOAABIRecorder3.c	2003-08-19 --jhg Changes for PicoDOS 3.x and FAT32**		**	NOAABIRecorder3.c		Generic Data Storage for BigIDEA**	**	1.0 release:		Tuesday, December 29, 1998**	1.1 release:		Monday, May 10, 1999**	1.2 release:		Sunday, July 18, 1999**	1.3 release:		Friday, August 27, 1999**		1.	Fixed bugs in BIRSetupNextVolume() and BIRFinish() which called**			BIRShutdown() with the wrong parameter causing it to not release**			the PicoZOOM cache. (source: Haru/NOAA)**		2.	Added mechanism to insert header information at the beginning**			of each file. This entails a great many changes to many parts of**			both this module and acquisition.c (for: Haru/NOAA)**	1.4 release: (NOAAVBIRecroder2.c) Thursday, Jan 9, 2002**      Added a line in BIRSetupNextVolume **			BIAReviseTiming((BIADEV)BIRS.BIADEVICE, 1000000, 60000000);**      This add an extra time for a disk to spin up. (HM, NOAA)**	1.5 release: (NOAABIRecorder3.c	Friday, June 28, 2002**		Changed LED light configuration.  Now indicates up to 7-th hard disk**		by binary LED display. **		Use "Pin 34" as OE enable controller of 74CBTLV16211 to pull down 16**		data output to the disk with 2.7k resistors to ground. (HM NOAA)****	1.6 release Added a gain resetting routine in BIRServiceOutgoingBuffers. At **		each file file writing each gain control pins are reset according to **		the right value handed over from noaalogger3_3.c. (3/21/03 HM)****	2.0	Changes for FAT32 plus buffer enhancements**		2003-08-19	Fix DEBUG diagnostics changes mixing up program logic --jhg*********************************************************************************	**	Licensed by:	Persistor Instruments Inc. for the Peristor CF1**	info@persistor.com - http://www.persistor.com**	*******************************************************************************	**	Developed by:	John H. Godley dba Peripheral Issues**	jhgodley@periph.com - http://www.periph.com**	Copyright (C) 1996-1998 Peripheral Issues.	All rights reserved.**	*******************************************************************************	**	Copyright and License Information**	**	Peripheral Issues (hereafter, PERIPH) grants you (hereafter, Licensee)**	a non-exclusive, non-transferable license to use the software source**	code contained in this single source file. Licensee may distribute**	binary derivative works using this software to third parties without**	fee or restrictions.**	**	PERIPH MAKES NO REPRESENTATIONS OR WARRANTIES ABOUT THE SUITABILITY OF THE**	BINARY SOFTWARE, EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO**	THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR**	PURPOSE, OR NON-INFRINGEMENT. PERIPH SHALL NOT BE LIABLE FOR ANY DAMAGES**	SUFFERED BY LICENSEE AS A RESULT OF USING, MODIFYING OR DISTRIBUTING THE**	BINARY SOFTWARE OR ITS DERIVATIVES.**	**	By using or copying this Software, Licensee agrees to abide by the**	copyright law and all other applicable laws of the U.S. including, but**	not limited to, export control laws, and the terms of this license. PERIPH**	shall have the right to terminate this license immediately by written**	notice upon Licensee's breach of, or non-compliance with, any of its**	terms. Licensee may be held legally responsible for any copyright**	infringement or damages resulting from Licensee's failure to abide by**	the terms of this license. **	\******************************************************************************/#define	BIR_VERSION_NUMBERS	3.4	// keep this up to date!!! - always V.R//#define DEBUG#ifdef DEBUG  #define	DBG(X)	X	// template:	DBG( uprintf("\n"); )  #pragma message	("!!! "__FILE__ ": Don't ship with DEBUG compile flag set!"    #define	LED1	35  #define	LED2	37  #define	DBG_SHOW_CF_WRITE_CYCLE_START()		do { PIOSet(LED1); PIOClear(LED2); } while (0)	// red off, green on  #define	DBG_SHOW_CF_WRITE_CYCLE_STOP()		do { PIOSet(LED2); } while (0)		// green off  #define	DBG_SHOW_HD_WRITE_CYCLE_START()		do { PIOClear(LED1); } while (0)	// red on  #define	DBG_SHOW_HD_WRITE_CYCLE_STOP()		do { PIOSet(LED1); } while (0)		// red off  #define	DONT_LOG_WHILE_DRIVE_ON		// to keep accellerated testing from failing  										// while we send out extra diagnostics.  										// This will create gaps in the data!#else  #define	DBG(X)		// nothing  #define	DBG_SHOW_CF_WRITE_CYCLE_START()  #define	DBG_SHOW_CF_WRITE_CYCLE_STOP()  #define	DBG_SHOW_HD_WRITE_CYCLE_START()  #define	DBG_SHOW_HD_WRITE_CYCLE_STOP()#endif#include	<cfxpico.h>		// Persistor PicoDOS Definitions#include <cfxbios.h>#include	<dosdrive.h>	// PicoDOS DOS Drive and Directory Definitions#include	<fcntl.h>		// PicoDOS POSIX-like File Access Definitions#include	<unistd.h>		// PicoDOS POSIX-like UNIX Function Definitions#include	<dirent.h>		// PicoDOS POSIX-like Directory Access Definitions#include	<stdio.h>#include	<stdlib.h>#include	<string.h>#include	<errno.h>#include	<time.h>#include	<BIRCFRecorder.h>	// BigIDEA-CF Recorder Definitions#include <BIRCFSettings.h>// Variables available only to the funtions in this modulestatic	BIRData	BIRS;						// runtime settings filled in at startup //static	uchar		*RamCFHDBufPtr = 0;	// dynamically alloced CF to HD buffer (big)//static	void		*RAMppb;					// dynamically alloced RAM ping-pong buffer (big)//static	void		*CFppb;					// CompactFlash ping-pong buffer (huge)static	long		MaxOnTimeout = 12L * 60L * 1000000;	// 12 minutes max (min*sec*us) //Changed by Haru, NOAA 02/17/2004static	short		FDbir = 0;				// File descriptor for low level read/write operationsstatic	bool		BIRCacheActive = false;	// PicoZOOM cache for hard drive is activestatic	bool		BIRDriveIsOn = false;	// drive is currently turned onstatic	bool		BIRAllDrivesFull = false;// all drives are now fullbool              AllDrivesFull=false;static	Callocf	*BIRcallocf;static	Freef		*BIRfreef;static	Collabf	*BIRCollab;				// BIR->ACT collaboration functionstatic	char		BIRdrvstr[4] = { 'x', ':', '\0', 0 };static	ulong		BIRLastSpinUpms = 0;static	ulong		BIRRemainingKB = 0;	// free space remaining on current drivestatic	bool		BIRInsertHeader = true;	// yes, for first timebool              DriveIsOn;// Functions available only to other funtions in this modulestatic	void	BIRGetSettings(void);static	short	BIRLogNewVolume(void);char *BIRNextFileName(bool hunt, bool incIndex, ulong *filecount);//static	void	BirUARTMonit(char c);short BIRSetupNextVolume(bool BIAChange, bool SlotChange);void  BIRShutdown(bool releaseCache);short BIRPowerUp(bool waitready);bool  BIRIncVolumeVars(bool shutdown);short BIRSetup(Callocf *callocf, Freef *freef, Collabf *collabf);void  BIRCFMasterToSlave(bool shutdown);void  BIRCFSlaveToMaster(bool shutdown);void  BIRCurrentSetup(short *BIACardNum, short *BIADevice, char *Drive);//July 2015void  PetWDog(void); //June 11, 2016 HM/******************************************************************************\**	BIRSetup		Perform one-time BIR setup using BIR environment variables**	on exit, drive is off, but current drive is set to the BIA\******************************************************************************/short BIRSetup(Callocf *callocf, Freef *freef, Collabf *collabf)	{	short		err = 0;  DBG( cprintf("\nBIRSetup(%lX, %lX, %lX)\n", callocf, freef, collabf); cdrain();)	CLEAR_OBJECT(BIRS);	// zero entire header/data structure (see <cf1bios.h>	BIRcallocf = callocf;	BIRfreef = freef;	BIRCollab = collabf;////	CONFIRM THE CORRECT SYSTEM SOFTWARE////	Must have at least PicoDOS 2.0	if (BIOSGVT.PICOVersion < 2)		return birDriverOutOfDate;//	PicoDOS 3.x required for BIRecorder	if (BIOSGVT.PICOVersion < 3)		return birDriverOutOfDate;//	Read in our control variables from VEE		BIRGetSettings();//	Insert header constants	if (sizeof(BIRS) != BIR_SYS_HDR_SIZE)	// data alignment mandates this		return birInvalidHdrSize;	strcpy(BIRS.BIRHdrID, "BIR");	BIRS.BIRVersion = BIR_VERSION_NUMBERS * 10;	// version.release * 10	BIRS.BIRUserHeaderSize = BIR_USER_HDR_SIZE;	// Display the control variables we'll be using	flogf("Program: %s, Ver: %3.1f, Build: %s %s\n", 		__FILE__, BIR_VERSION_NUMBERS, __DATE__, __TIME__);	//flogf(" ## BIRS.CFPPBSZ    =%ld\n", BIRS.CFPPBSZ);	//flogf(" ## BIRS.MINFREEKB  =%ld\n", BIRS.MINFREEKB);	flogf(" ## BIRS.CFDOSDRV[0]=%s\n", BIRS.CFDOSDRV);	flogf(" ## BIRS.FLOGFLAG   =%d\n", BIRS.FLOGFLAG);	flogf(" ## BIRS.CURBIA     =%d\n", BIRS.CURBIA);	flogf(" ## BIRS.BIADEVICE  =%d\n", BIRS.BIADEVICE);////	INITIALIZE THE IDE ADAPTER//	if ((err = BIRSetupNextVolume(false, false)) != 0)//no slot change		return err;	return 0;	}	//____ BIRSetup() ____///******************************************************************************\**	BIRSetupNextVolume		Select and prepare the next DOS volume **	**	This is called at program startup. After a file is written, free space becomes **	less than the minimum required, it either switches from master to slave or to ** the next BIA drive's master, if there is any left. The drive is always turned off ** on conclusion. HM****	Returns: zero for ok, or birNoFreeSpace if no viable DOS volumes found.**	**	The sequencing for four BigIDEAs, each with one DOS partition is:**		BigIDEA index 0		(index 0 is lowest serial number)**		BigIDEA index 1		(index 1 is next lowest SN#)**    ...............**		BigIDEA index x		(index x is highest serial number) **		returns birNoFreeSpace**  Max BigIDEA is determined in BIRCFRecorder.h (BIR_MAX_BIGIDEA)**	**	There should never be any missing BigIDEAs since the index numbers are**	assigned by the SCS driver when they are discovered at startup. If**	one BigIDEA should fails to respond, the sofware skips to the next BigIDEA ** and moves on to the next until it checks to the last BigIDEA.**	**	The switching logic is controlled by two system globals:**		BIRDriveIsOn	true when the drive is powered**		BIRS.CURBIA		the BigIDEA index to use at the next call to here**    BIRS.BIADEVICE =3 master and =4 slave**	Note that the last global is also stored in the persistant VEE to give**	the system a chance of intelligent resumption in the event of a full**	**	Drive switching occurs only at startup (normal or crash-resume) or as**	a result of the free capacity check that is performed at the tail end**	of file write.**	**	The function uses this knowledge to determine if a BigIDEA switch is**	required (yes, if drive is currently off). The BigIDEA select**	is set up in a while loop to allow unexpected errors to force a move**	to the next BigIDEA by incrementing and saving the CURBIA variable.**	**	If the DOS mounting goes well, we setup the file naming for future**	data writes and if this too goes well, we shutdown the drive and**	return zero indicating no errors. If not, we recurse again using the**	same technique in the paragraph above.**\******************************************************************************/short BIRSetupNextVolume(bool BIAChange, bool SlotChange)	{	ulong    filecount;	RTCTimer	startTimer;	long		startms = 0;	char		*idxfname;	short		err = 0;	FILE 		*fp = 0;	char     mounts[] = "mount x: bfcs-";//command to mount e: drive	char     mountm[] = "mount x: bfcm-";	ulong 	starttime, endtime;	ulong		timediff;	ushort	WD_Int_Lvl;		switch(BIRS.BIADEVICE){      case 3:     	BIRS.CFDOSDRV[0]='D'+BIRS.CURBIA*2;//Added July 2015      flogf("Current BigIDEA drive = %d, Master %c:\n", BIRS.CURBIA, BIRS.CFDOSDRV[0]);      break;      case 4:     	BIRS.CFDOSDRV[0]='E'+BIRS.CURBIA*2;//Added July 2015      flogf("Current BigIDEA drive = %d, Slave %c:\n", BIRS.CURBIA, BIRS.CFDOSDRV[0]);      break;	}	BIRdrvstr[0] = BIRS.CFDOSDRV[0];	// for calls that use drive letters //moved here July 2015	//flogf("Current drive = %d, Master(3)/Slave(4)=%d\n", BIRS.CURBIA, BIRS.BIADEVICE);		  DBG( flogf("\n[BSNV%d]=BIRSetupNextVolume()\n", __LINE__);  cdrain();)	if (BIRS.NODRVTEST)	// just return if we're testing without drive		return 0;// There are three ways we get to this point://	1. From initial program startup (with drive off)//	2. After completion of the last file write forces a volume switch//	3. Recursing from within this function// If we get here with the drive off (condition 1 or 3), we're expecting// to be setting up the current BigIDEA drive - which will be off on entry.   if(SlotChange==true){  	  DBG( flogf("\t[BSNV%d]: Slot change. Current BIRS.CURBIA=%d, BIRS.BIADEVICE=%d\n",__LINE__, 	     BIRS.CURBIA,  BIRS.BIADEVICE);  cdrain();)      if(BIRS.BIADEVICE==3)BIRCFMasterToSlave(false);//force switch to slave drive on current BIA HM      else if(BIRS.BIADEVICE==4)          {         BIRCFSlaveToMaster(false);//change BigIDEA		   if(!BIRIncVolumeVars(true))return -1;		 // force switch to next BigIDEA's master and shutdown drive HM               }      }      	while (! BIRDriveIsOn)	// keep trying until we get it right, or run out		{	  DBG( flogf("\t[BSNV%d]: while (! BIRDriveIsOn[%d])\n", __LINE__, BIRDriveIsOn);  cdrain();)		//if (BIRS.CURBIA >= BIR_MAX_BIGIDEA)		// we've exhausted drives		//Check if it is a slave drive also HM		//BIADEVICE=3 master, =4 slave		if (BIRS.CURBIA >= BIR_MAX_BIGIDEA)		// we've exhausted drives			{		  DBG( flogf("\t[BSNV%d]: BIRAllDrivesFull, return birNoFreeSpace\n", __LINE__);  cdrain();)			BIRAllDrivesFull = true;	// set flag so we can stop			AllDrivesFull    = true;			return birNoFreeSpace;			} 		if ((err = BIAInit((BIADEV) BIRS.BIADEVICE, BIA_DEFAULT_SCB, BIRS.CURBIA, BIA_DEFAULT_NS)) != 0)			{		  DBG( flogf("\t[BSNV%d]: BIAInit=%d, BIRS.CURBIA=%d BIRS.BIADEVICE=%d\n", __LINE__, err, BIRS.CURBIA, BIRS.BIADEVICE);  cdrain();)			//BIRIncVolumeVars(true);		// force switch to next BigIDEA and shutdown drive			if(BIRS.BIADEVICE==4)			   {			   BIAChange=false;			   SlotChange=false;			   BIRCFSlaveToMaster(false);			   if(!BIRIncVolumeVars(true))return -1;		 // force switch to next BigIDEA's master and shutdown drive HM			   }else BIRCFMasterToSlave(false);			continue;	// and try again with a new BIA from the nearest while start			}	//	So far, so good - startup the drive and make sure it responds.		RTCElapsedTimerSetup(&startTimer); 		BIAReviseTiming((BIADEV)BIRS.BIADEVICE, 2000000, 60000000);	// allow longer spin up time 12/20/2001 HM		if (! BIRPowerUp(true))	// and wait for ready			{		   BIAChange=false;		   SlotChange=false;		  DBG( flogf("\t[BSNV%d]: BIRPowerUp timed out, BIRS.CURBIA=%d\n", __LINE__, BIRS.CURBIA);  cdrain();)			if(BIRS.BIADEVICE==4)			   {			   BIRCFSlaveToMaster(false);			   if(!BIRIncVolumeVars(true))return -1;		// force switch to next BigIDEA's master and shutdown drive HM			   }else BIRCFMasterToSlave(false);   			continue;	// and try again			}		// BIA initiated properly andBIRDriveIsOn will now be true so we'll break		// cleanly from loop on the next iteration.		startms = RTCElapsedTime(&startTimer) / 1000;		}// Once we know the drive is powered, we mount the first volume. We don't// know or care if we entered this function powered, but we will look at// globals to perform any necessary cleanup before switching volumes.// DEAL WITH DRIVE CURRENTLY MOUNTED - PRESUMABLE GOT HERE BECAUSE FULL	// The only way we could have gotten here with a mounted drive is when the 	// last write operation filled past the minimum capacity, or if our attempt	// to setup a drive in an earlier recursion failed, now we need to dismount	// the current volume and perform a drive switch.	RTCDelayMicroSeconds(1000000);//HM		if ((err = DSDValidate(BIRS.CFDOSDRV[0] - 'A')) == 0)	// mounted ?		{		err = DSDMountATADevice("", 0, 0, -(BIRS.CFDOSDRV[0] - 'A'));	// negative dismounts	  DBG( flogf("\t[BSNV%d]: Dismounted BIRS.CURBIA=%d: DSDMountATADevice(%d)=%d\n", __LINE__, 	     BIRS.CURBIA,  -(BIRS.CFDOSDRV[0] - 'A'), err);  cdrain();)		BIAChange=false;		SlotChange=false;		return BIRSetupNextVolume(BIAChange, SlotChange);// with drive off, recursion will try again with next BIA		}// MOUNT THE FIRST VOLUME TO MAKE SURE WE'LL HAVE ACCESS WHEN NEXT NEEDED	err = DSDMountATADevice(BIAGetDriverName((BIADEV) BIRS.BIADEVICE),	BIAGetDriver((BIADEV) BIRS.BIADEVICE), 0, BIRS.CFDOSDRV[0] - 'A');  	DBG( flogf("\t[BSNV%d]: DSDMountATADevice=%d\n", __LINE__, err);  cdrain();)	if (err)	// at this point, we haven't successfully mounted, so we just hop back		{	  DBG( flogf("\t[BSNV%d]: DSDMountATADevice failed :err=%d, BIRS.CURBIA=%d\n", __LINE__, err, BIRS.CURBIA);  cdrain();)			if(BIRS.BIADEVICE==4)		   {		   BIAChange=true; 		   SlotChange=true;		  // BIRS.CFDOSDRV[0]='D'; //could be F, H, J		   }else		   {		   BIAChange=false;		   SlotChange=true;		   //BIRS.CFDOSDRV[0]='E'; //Could be G, I, K		   }		return BIRSetupNextVolume(BIAChange, SlotChange);// with drive off, recursion will try again with next BIA		}	//if (! (BIRCacheActive = PZCacheSetup(BIRS.CFDOSDRV[0] - 'A', BIRcallocf, BIRfreef)))	//	{  	//DBG( flogf("\t[BSNV%d]: PZCacheSetup failed! continuing anyway\n", __LINE__, err);  cdrain();)		// err = birCacheSetupFailed;		// we want the cache and expect to get, but if it fails, we plug along		// and just fall through	//	}		//	// 	First file name search.	//errno = 0;	idxfname = BIRNextFileName(true, false, &filecount);	// do hunt, don't increment		DBG( flogf("\t[BSNV%d]: BIRS.CFDOSDRV=%c:\n", __LINE__, BIRS.CFDOSDRV[0]); cdrain(););//July 29, 2015	starttime=time(0); //DEBUG	DBG(cprintf("ctime = %lu\n", starttime);cdrain();)//DBUG		//Added June 12, 2016 HM	WD_Int_Lvl=5;	TickleSWSR();	PITInit(WD_Int_Lvl);				  	PITSet51msPeriod(255); //13 sec chore interval	PITAddChore(PetWDog,WD_Int_Lvl);	//This process takes a 450 sec for 512 GB	BIRS.BIRStartFreeKB=(DSDFreeSectors(BIRS.CFDOSDRV[0] - 'A') / 2);		//DBUG Added June 12, 2016 HM	endtime=time(0);	DBG(cprintf("ctime = %lu\n", endtime);cdrain();)//DEBUG	timediff=endtime-starttime;	flogf("Elapsed time for mounting %lu\n", timediff); putflush();//DEBUG				BIRS.BIRCapacityKB = DSDDataSectors(BIRS.CFDOSDRV[0] - 'A') / 2;		//Remove chore June 11, 2016	PITSet51msPeriod(PITOff);	PITRemoveChore(PetWDog);	BIRRemainingKB=BIRS.BIRStartFreeKB;	DBG( flogf("\t[BSNV%d]: BIRRemainingKB=%lu, BIRS.BIRCapacityKB=%lu\n", __LINE__, BIRRemainingKB, BIRS.BIRCapacityKB);  cdrain();)	RTCElapsedTime(&startTimer);	//Change the BIA drive	if (err || BIRRemainingKB < BIRS.MINFREEKB)		{	  DBG( flogf("\t[BSNV%d]: if (err || BIRRemainingKB < BIRS.MINFREEKB):err=%d, BIRS.CURBIA=%d\n", __LINE__, err, BIRS.CURBIA);  cdrain();)	  if(BIRRemainingKB < BIRS.MINFREEKB) flogf("Free space %ld kB left. Not enough on this disk.\n", BIRRemainingKB); 			if(BIRS.BIADEVICE==4)		   {		   BIAChange=true; 		   SlotChange=true;		   //BIRS.CFDOSDRV[0]='D';   		   }else		   {		   BIAChange=false;		   SlotChange=true;		   //BIRS.CFDOSDRV[0]='E';   		   }		return BIRSetupNextVolume(BIAChange, SlotChange);	// with drive off, recursion will try again with next BIA		}	BIRLogNewVolume();	sprintf(&mountm[14],"%01d", BIRS.CURBIA);	sprintf(&mounts[14],"%01d", BIRS.CURBIA);		if(BIRS.BIADEVICE==3){ //only the master is mounted		sprintf(&mounts[6],"%c: bfcs-%01d",'E'+BIRS.CURBIA*2, BIRS.CURBIA);		flogf("Only the master is mounted. Mount slave. %s:",mounts);		execstr(mounts);    //mount slave as e:		}	//if(BIRS.BIADEVICE==4){//slave	//	sprintf(&mountm[6],"%c",'D'+BIRS.CURBIA*2);	//	flogf("Mounting %c:\n", mountm[6]); 	//	execstr(mountm);   //mount master as d:	//	}	  DBG( flogf("\t[BSNV%d]: BIRS.CURBIA=%d BIRS.BIADEVICE=%d %c: return 0\n", __LINE__, BIRS.CURBIA, BIRS.BIADEVICE, BIRS.CFDOSDRV[0]);  cdrain();)	return 0;		}	//____ BIRSetupNextVolume() ____///******************************************************************************\**	BIRIncVolumeVars		Advance to the next BigIDEA volume and save in VEE** **	Change to master CF card slot if it was a slave. HM 9/20/2011**	Returns false if increment exceeds available volumes\******************************************************************************/bool BIRIncVolumeVars(bool shutdown)	{	char		CURBIAStr[2] = { '\0', '\0' };	// for saving to VEE	char     CURBIADev[2] = { '\0', '\0' };	//BIRS.CURBIA++;								   // next BigIDEA	//CURBIAStr[0] = BIRS.CURBIA + '0';			// convert to string	//VEEStoreStr(BIR_CURBIA_NAME, CURBIAStr);// and save it		BIRS.BIADEVICE=3;                         //force it master CF 3=master HM	CURBIADev[0] = BIRS.BIADEVICE + '0';		// convert to string	VEEStoreStr(BIR_BIADEVICE_NAME, CURBIADev);	// and save it	  //DBG( cprintf("\n[BIVV%d]=BIRIncVolumeVars(%d): BIRS.CURBIA=%d to %d, BIADEVICE=%d\n", \  //__LINE__, shutdown, BIRS.CURBIA-1, BIRS.CURBIA, BIRS.BIADEVICE);  cdrain();)	if (shutdown)		BIRShutdown(true); 	//shut down the current BigIDEA volume	  DBG( cprintf("\t[BIVV%d]: exit BIRS.CURBIA=%d BIR.BIADEVICE=%d\n", __LINE__, BIRS.CURBIA, BIRS.BIADEVICE);  cdrain();)	//Moved from the top July 29, 2015. Shutting down the previous volume first and increment	//the volume (CURBIA).	BIRS.CURBIA++;								      // next BigIDEA	CURBIAStr[0] = BIRS.CURBIA + '0';			// convert to string	VEEStoreStr(BIR_CURBIA_NAME, CURBIAStr);	// and save it		  DBG( cprintf("\n[BIVV%d]=BIRIncVolumeVars(%d): BIRS.CURBIA=%d to %d, BIADEVICE=%d\n", \  __LINE__, shutdown, BIRS.CURBIA-1, BIRS.CURBIA, BIRS.BIADEVICE);  cdrain();)return BIRS.CURBIA < BIR_MAX_BIGIDEA ? true : false;		}	//____ BIRIncVolumeVars() ____///******************************************************************************\**	BIRPowerUp\******************************************************************************/short BIRPowerUp(bool waitready)	{	BIAST		biast;	RTCTimer	tmtest;	  DBG( cprintf("\n[BPWRUP%d]=BIRPowerUp(%d) BIRS.CURBIA=%d BIRS.BIADEVICE=%d BIRS.CFDOSDRV[0]=%c:\n", \  __LINE__, waitready, BIRS.CURBIA, BIRS.BIADEVICE, BIRS.CFDOSDRV[0]);  cdrain();)	if (BIRS.NODRVTEST)	// just return if we're testing without drive		return 0;	BIRDriveIsOn = true;	// just the attempt is enough	RTCElapsedTimerSetup(&tmtest);	BIRCollab(turningOn, &BIRS, 0);		// notify ACQ that we're turning on	BIAPowerUp(false);		// power up but don't wait	if (! waitready)		// jobs done		return true;	do	{		biast = BIAGetStatus();		if (biast.ready)			break;		//BIRServiceIncommingBuffers();	// give data pump some CPU time.		} while (waitready && biast.spinup && ! biast.timedout);	// This code is required only for pre rev C BigIDEAs which have drive INTRQ 	// connected to IRQ2 which floods IRQ2 with interrupts before drive is RDY		if (biast.ready)			BIAGetPortInfo(0)->idePort[0x26] = 0x0A00;	// disable future INTRQs  RTCElapsedTime(&tmtest);  DBG( cprintf("\t[BPWRUP%d] returns %d [%ldus to not busy]\n", __LINE__, biast.ready, RTCElapsedTime(&tmtest));  cdrain();)	return biast.ready;	}	//____ BIRPowerUp() ____///******************************************************************************\**	BIRShutdown\******************************************************************************/void BIRShutdown(bool releaseCache)	{	DBG(flogf("\n[BSHDN%d]=BIRShutdown(%d)\n", __LINE__, releaseCache));  cdrain();	if (BIRS.NODRVTEST)	// just return if we're testing without drive		return;	if (BIRDriveIsOn)	// drive is currently turned on		{		if (BIRCacheActive)	// PicoZOOM cache for hard drive is active			{			if (releaseCache)				{				PZCacheRelease(BIRS.CFDOSDRV[0] - 'A');				BIRCacheActive = false;				}			else				{				PZCacheFlush(BIRS.CFDOSDRV[0] - 'A');				}			}		// The following line will update FAT32 hints sector with up-to-date info		DSDResetOptimizations((BIRS.CFDOSDRV[0] - 'A') | DSD_COMMIT_HINTS_MASK);		BIRCollab(turningOff, &BIRS, 0);		// notify ACQ that we're turning off		BIAShutDown();		BIRDriveIsOn = false;		RTCDelayMicroSeconds(100000);	// let it settle for 100ms		DriveIsOn=BIRDriveIsOn;		}	}	//____ BIRShutdown() ____///******************************************************************************\**	BIRCheckCapacityKB	Returns the free space in KB on the current disk drive\******************************************************************************/long BIRCheckCapacityKB(void)	{	if (BIRAllDrivesFull)	// 99/07/19		return 0;	// effectively		return BIRRemainingKB;	}	//____ BIRCheckCapacity() ____///******************************************************************************\**	BIRUpdateHeader		Update header information\******************************************************************************///void BIRUpdateHeader()//	{//	RTCGetTime(&BIRS.RTCsecs, &BIRS.RTCticks);	// update date and time	//	}	//____ BIRUpdateHeader() ____///******************************************************************************\**	BIRErrorString		Return C string corrosponding to errcode\******************************************************************************/char *BIRErrorString(short errcode)	{	char	*birerrstrs[] =		{		  "unknown BIRS error code"		, "timed out waiting for spin-up ready"		, "timed out completing the write"		, "couldn't set up PicoZOOM"		, "problem opening the index file"		, "problem writing the index file"		, "problem closing the index file"		, "problem opening the data log file"		, "problem writing the data log file"		, "problem closing the data log file"		, "problem allocating memory for ram PPB"		, "problem opening the ram PPB"		, "problem reading the ram PPB"		, "problem allocating memory for CF buffer"		, "problem finding any CF buffer SSD"		, "problem finding big enough CF buffer SSD"		, "problem registering CF buffer SSD to BSD"		, "problem opening the CF PPB"		, "problem writing the CF PPB"		, "problem writing the RAM PPB"		, "no free space left to record"		, "required drivers are out of date"		, "unknown IDE device"		, "sizeof(header) doesn't match constant"		};	if (errcode <= birErrorStart || errcode > birUnknownIDEDevice)		return birerrstrs[0];		return birerrstrs[errcode - birErrorStart];	}	//____ BIRErrorString() ____///******************************************************************************\**	BIRGetSettings		Read in settings from VEE or use defaults if not found****	Look in <BIRecorder.h> for detailed descriptions of the variables.\******************************************************************************/ static void BIRGetSettings(void)	{	//	UARTMONIT	Send status strings to RS-232 port (when non-zero). For testing only.//	BIRS.UARTMONIT = VEEFetchLong(BIR_UARTMONIT_NAME, atol(BIR_UARTMONIT_DEFAULT));//		DBG( cprintf("BIRS.UARTMONIT=%u\n", BIRS.UARTMONIT);  cdrain();)//	FLOGFLAG	Log major operating events (when non-zero). Normally enabled.	BIRS.FLOGFLAG = VEEFetchLong(BIR_FLOGFLAG_NAME, atol(BIR_FLOGFLAG_DEFAULT));		DBG( cprintf("BIRS.FLOGFLAG=%u\n", BIRS.FLOGFLAG);  cdrain();)// Additions 99/07/18//	CFDOSDRV	DOS drive letter for hard disk	strncpy(BIRS.CFDOSDRV, VEEFetchStr(BIR_CFDOSDRV_NAME, BIR_CFDOSDRV_DEFAULT), sizeof(BIRS.CFDOSDRV));		DBG( cprintf("BIRS.CFDOSDRV=%s\n", BIRS.CFDOSDRV);  cdrain();)//	MINFREEKB	Minimum free KB to continue use of current hard disk volume	BIRS.MINFREEKB = VEEFetchLong(BIR_MINFREEKB_NAME, atol(BIR_MINFREEKB_DEFAULT));	if (BIRS.MINFREEKB == 0)	// Fill in default if not explicitly defined 		BIRS.MINFREEKB = (BIRS.CFPPBSZ / 2) / KB_SIZE;		DBG( cprintf("BIRS.MINFREEKB=%lu\n", BIRS.MINFREEKB);  cdrain();)//	CURBIA	Index for current BigIDEdrive	BIRS.CURBIA = VEEFetchLong(BIR_CURBIA_NAME, atol(BIR_CURBIA_DEFAULT));		DBG( cprintf("BIRS.CURBIA=%u\n", BIRS.CURBIA);  cdrain();)		//	BIADEVICE		BigIDEA device type	BIRS.BIADEVICE = (BIADEV) VEEFetchLong(BIR_BIADEVICE_NAME, atol(BIR_BIADEVICE_DEFAULT));		DBG( cprintf("BIRS.BIADEVICE=%u\n", BIRS.BIADEVICE);  cdrain();)	BIRCollab(gotSettings, &BIRS, 0);	// notify ACQ that we've got settings	}	//____ BIRGetSettings() ____///******************************************************************************\**	BIRLogNewVolume		Log our startup event\******************************************************************************/static short BIRLogNewVolume(void)	{	//Added 6 parameters associated with the CF card size July 29 2015	long	freeSpacekB;	long 	totalSpacekB;	long  freeSectors;	long  totalSectors;	long  freeByteskB;	long  filesizeB;  		if (BIRS.FLOGFLAG == 0)		return 0;	flogf("\nNew volume: %s [ctime: %lu]\n", BIRCollab(reqTimeStr, &BIRS, 0), time(0));	switch(BIRS.BIADEVICE){      case 3: 			BIRS.CFDOSDRV[0]='D'+BIRS.CURBIA*2;			//D, F, H, J  July 2015      	flogf("BigIDEA %d Master Drive %c: (%u:%lu), Spin-up %lums\n",      	BIRS.CURBIA, BIRS.CFDOSDRV[0], BIAGetPortInfo(0)->biaIndex, BIAGetPortInfo(0)->scsDev & 0xFFFF, BIRLastSpinUpms);			//BIRS.CFDOSDRV[0]='D';							//back to D:			VEEStoreStr(BIR_CFDOSDRV_NAME,BIRS.CFDOSDRV);	      break;      case 4: 			BIRS.CFDOSDRV[0]='E'+BIRS.CURBIA*2;			//E, G, I, K, & etc July 2015      	flogf("BigIDEA %d Slave Drive %c: (%u:%lu), Spin-up %lums\n",      	BIRS.CURBIA, BIRS.CFDOSDRV[0], BIAGetPortInfo(0)->biaIndex, BIAGetPortInfo(0)->scsDev & 0xFFFF, BIRLastSpinUpms);			VEEStoreStr(BIR_CFDOSDRV_NAME,BIRS.CFDOSDRV);	      break;      }            //Added the following 14 lines July 29 2015      freeSectors  = DSDFreeSectors( BIRS.CFDOSDRV[0]-'A');   	totalSectors = DSDDataSectors( BIRS.CFDOSDRV[0]-'A');   	freeSpacekB  = freeSectors/2;   	totalSpacekB = totalSectors/2;            //??   	freeByteskB  = freeSpacekB;   	filesizeB    = BIRS.CFPPBSZ; 		TickleSWSR();	// another reprieve            flogf("BigIDEA card number   = %d\n", BIRS.CURBIA);      flogf("Master(3)/slave(4)    = %d\n", BIRS.BIADEVICE);       flogf("Drive                   %c:\n", BIRS.CFDOSDRV[0]);    	flogf("Disk size             = %ld kB\n", totalSpacekB);   	flogf("Total Free Disk Space = %ld kB\n", freeSpacekB);   	//end    	return 0;	}	//____ BIRLogNewVolume() ____///******************************************************************************\**	BIRNextFileName		\******************************************************************************/char *BIRNextFileName(bool hunt, bool incIndex, ulong *filecount)	{//	ulong			val, maxval = 0;//	static ulong	counter = 0;	static long		counter = -1;		// 2003-08-21	long			   val, maxval = -1;	// 2003-08-21	static char		dfname[] = "x:00000000.DAT";	static char		path[] = "x:";	DIRENT			de;	short			   err;	short			   i;	if (hunt)		// only do this when requested (usually just at first mount)		{		path[0] = dfname[0] = BIRS.CFDOSDRV[0];		if ((err = DIRFindFirst(path, &de)) != dsdEndOfDir)			{			do	{				if (err != 0)					break;				if (de.d_name[9] == 'D' && de.d_name[10] == 'A' && de.d_name[11] == 'T')					{					for (i = val = 0; i < 8; i++)						if (de.d_name[i] >= '0' && de.d_name[i] <= '9')							val = (val * 10) + de.d_name[i] - '0';						else							break;					if (i == 8) 	// all digits						if (val > maxval)							maxval = val;					}				} while (DIRFindNext(&de) != dsdEndOfDir);			}		if (maxval < 0 && counter < 0)	// 2003-08-27			counter = 0;	// 2003-08-21		//if (maxval > counter)	// 99/07/22		else if (maxval > counter)	// 2003-08-21			counter = maxval + 1;		}	sprintf(&dfname[2], "%08lu.DAT", counter);		if (incIndex)		counter++;		*filecount=(ulong) counter;	return dfname;	}	//____ BIRNextFileName() ____///******************************************************************************\**	BirUARTMonit\******************************************************************************///static void BirUARTMonit(char c)//	{//	static char	col = 0;	//	if (col++ > 66)//		{//		cputc('\r');//		cputc('\n');//		col = 0;//		}//	cputc(c);//	cdrain();	//	}	//____ BirUARTMonit() ____//	//**********************************************************************************************************// BIRCFMasterToSlave(bool shutdown)// Force to switch from master to slave CF card on the same BIRS.CURBIA.  // H. Matsumoto//**********************************************************************************************************void BIRCFMasterToSlave(bool shutdown)	   {  	char     CURBIADev[2] = { '\0', '\0' };	BIRS.BIADEVICE=4;                            //force it slave CF. 4=slave HM	CURBIADev[0] = BIRS.BIADEVICE + '0';		   //convert to string	VEEStoreStr(BIR_BIADEVICE_NAME, CURBIADev);	//and save it   //BIRS.CFDOSDRV[0]='E';	   BIRS.CFDOSDRV[0]='E' + BIRS.CURBIA*2;			//July 2015	  DBG( flogf("\n[BIVV%d]=BIRCFMasterToSlave(%d): BIRS.CURBIA=%d, BIADEVICE=%d\n",\   __LINE__, shutdown, BIRS.CURBIA, BIRS.BIADEVICE);  cdrain();)	if (shutdown)		BIRShutdown(true);	  DBG( flogf("\t[BIVV%d]: exit BIRS.CURBIA=%d BIR.BIADEVICE=%d\n", __LINE__, BIRS.CURBIA, BIRS.BIADEVICE);  cdrain();)   //return BIRS.CURBIA < BIR_MAX_BIGIDEA ? true : false;		}	//____ BIRCFMasterToSlave() ____////**********************************************************************************************************// BIRCFSlaveToMaster(bool shutdown)// Rev. July 29, 2015// Force to switch from slave to master CF card.  // H. Matsumoto//**********************************************************************************************************void BIRCFSlaveToMaster(bool shutdown)	   {  	char     CURBIADev[2] = { '\0', '\0' };	BIRS.BIADEVICE=3;                         //force it master CF. 4=slave HM	CURBIADev[0] = BIRS.BIADEVICE + '0';		// convert to string	VEEStoreStr(BIR_BIADEVICE_NAME, CURBIADev);	// and save it   //BIRS.CFDOSDRV[0]='D';      BIRS.CFDOSDRV[0]='D'+(BIRS.CURBIA+1)*2;	//July 29, 2015 Next drive letter   	  DBG( flogf("\n[BIVV%d]=BIRCFSlaveToMaster(%d): BIRS.CURBIA=%d to %d, BIADEVICE=%d Drive %c:\n", \  __LINE__, shutdown, BIRS.CURBIA, BIRS.CURBIA+1, BIRS.BIADEVICE, BIRS.CFDOSDRV[0]);  cdrain();)	if (shutdown)		BIRShutdown(true);	  DBG( flogf("\t[BIVV%d]: exit BIRS.CURBIA=%d BIR.BIADEVICE=%d\n", __LINE__, BIRS.CURBIA, BIRS.BIADEVICE);  cdrain();)   //return BIRS.CURBIA < BIR_MAX_BIGIDEA ? true : false;		}	//____ BIRCFSlaveToMaster() ____////**************************************************************************// Fetch the current BIA setup//Added July 2015//**************************************************************************void BIRCurrentSetup(short *BIACardNum, short *BIADevice, char *Drive)	{	*BIACardNum=BIRS.CURBIA;	*BIADevice=BIRS.BIADEVICE;	Drive[0]=BIRS.CFDOSDRV[0];	}//*****************************************************************************//Watch dog pet routine// Jne 11, 2016//****************************************************************************	void PetWDog(void){	//DBG(flogf("PetWDog\n");cdrain();)//DEBUG	TickleSWSR();}