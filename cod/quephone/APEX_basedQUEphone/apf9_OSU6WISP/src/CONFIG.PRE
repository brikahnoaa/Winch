
# 1 "C:\APF9_NEW\SRC\CONFIG.C"

# 4 "C:\HT-XA\INCLUDE\time.h"
typedef int ptrdiff_t;
typedef unsigned size_t;
typedef unsigned short wchar_t;




typedef long time_t;
struct tm {
int tm_sec;
int tm_min;
int tm_hour;
int tm_mday;
int tm_mon;
int tm_year;
int tm_wday;
int tm_yday;
int tm_isdst;
};

# 30
extern int time_zone;

# 35
extern time_t time(time_t *);
extern int stime(time_t *);
extern char * asctime(struct tm *);
extern char * ctime(time_t *);
extern struct tm * gmtime(time_t *);
extern struct tm * localtime(time_t *);
extern time_t mktime(struct tm *);
extern size_t strftime(char *, size_t, const char *, const struct tm *);

# 87 "C:\APF9_NEW\SRC\CONFIG.C"
struct MissionParameters
{
unsigned int FloatId;
unsigned char MaxAirBladder;
unsigned char OkVacuumCount;
unsigned char PistonBuoyancyNudge;
unsigned char PistonDeepProfilePosition;
unsigned char PistonFullExtension;
unsigned char PistonFullRetraction;
unsigned char PistonInitialBuoyancyNudge;
unsigned char PistonParkHyperRetraction;
unsigned char PistonParkPosition;
unsigned char PistonStoragePosition;
unsigned char PnpCycleLength;
float PressurePark;
float PressureProfile;
float PressureCP;
time_t TimeDeepProfileDescent;
time_t TimeDown;
time_t TimeOutAscent;
time_t TimeParkDescent;
time_t TimePrelude;
time_t TimeTelemetryRetry;
time_t TimeUp;
time_t ToD;
time_t ConnectTimeOut;
char alt[(63)+1];
char at[(63)+1];
char pwd[16];
char user[16];
unsigned int crc;
};


int configure(struct MissionParameters *config, const char *fname);
int inRange(double a,double x,double b);
int inCRange(double a,double x,double b);
int LogConfiguration(const struct MissionParameters *config,const char *id);

# 133
extern persistent struct MissionParameters mission;


extern const struct MissionParameters DefaultMission;


extern const char config_path[];


extern persistent char log_path[32];


extern const unsigned long FwRev;


extern const time_t TQuantum;

# 154
extern const float dPdt;


extern const float MinN2ParkPressure;




const time_t TQuantum = (60L);

# 48 "C:\HT-XA\INCLUDE\stdlib.h"
typedef struct {
int quot;
int rem;
} div_t;
typedef struct {
unsigned quot;
unsigned rem;
} udiv_t;
typedef struct {
long quot;
long rem;
} ldiv_t;
typedef struct {
unsigned long quot;
unsigned long rem;
} uldiv_t;

# 69
extern double atof(const char *);
extern double strtod(const char *, const char **);
extern int atoi(const char *);
extern unsigned xtoi(const char *);
extern long atol(const char *);
extern int rand(void);
extern void srand(unsigned int);
extern void * calloc(size_t, size_t);
extern div_t div(int numer, int denom);
extern udiv_t udiv(unsigned numer, unsigned denom);
extern ldiv_t ldiv(long numer, long denom);
extern uldiv_t uldiv(unsigned long numer,unsigned long denom);
extern unsigned long _lrotl(unsigned long value, unsigned int shift);
extern unsigned long _lrotr(unsigned long value, unsigned int shift);
extern unsigned int _rotl(unsigned int value, unsigned int shift);
extern unsigned int _rotr(unsigned int value, unsigned int shift);

# 108
extern void * malloc(size_t);
extern void free(void *);
extern void * realloc(void *, size_t);

# 124
extern void abort(void);
extern void exit(int);
extern int atexit(void (*)(void));
extern char * getenv(const char *);
extern char ** environ;
extern int system(char *);
extern void qsort(void *, size_t, size_t, int (*)(const void *, const void *));
extern void * bsearch(const void *, void *, size_t, size_t, int(*)(const void *, const void *));
extern int abs(int);
extern long labs(long);

# 16 "C:\HT-XA\INCLUDE\assert.h"
extern void _fassert(int, char *, char *);

# 23 "C:\HT-XA\INCLUDE\string.h"
extern void * memcpy(void *, const void *, size_t);
extern void * memmove(void *, const void *, size_t);
extern char * strcpy(char *, const char *);
extern char * strncpy(char *, const char *, size_t);
extern char * strcat(char *, const char *);
extern char * strncat(char *, const char *, size_t);
extern int memcmp(const void *, const void *, size_t);
extern int strcmp(const char *, const char *);
extern int stricmp(const char *, const char *);
extern int strncmp(const char *, const char *, size_t);
extern int strnicmp(const char *, const char *, size_t);
extern size_t strcoll(char *, size_t, char *);
extern  void * memchr(const void *, int, size_t);
extern size_t strcspn(const char *, const char *);
extern  char * strpbrk(const char *, const char *);
extern size_t strspn(const char *, const char *);
extern  char * strstr(const char *, const char *);
extern  char * stristr(const char *, const char *);
extern char * strtok(char *, const char *);
extern char * strdup(const char *);
extern void * memset(void *, int, size_t);
extern char * strerror(int);
extern size_t strlen(const char *);
extern  char * strchr(const char *, int);
extern  char * strichr(const char *, int);
extern  char * strrchr(const char *, int);
extern  char * strrichr(const char *, int);

# 29 "C:\HT-XA\INCLUDE\ctype.h"
extern code unsigned char _ctype_[257];

# 46
extern char toupper(int);
extern char tolower(int);

# 5 "c:\apf9_new\include\crc16bit.h"
unsigned int Crc16Bit(const unsigned char *msg,unsigned int len);

# 4 "c:\apf9_new\include\extract.h"
char *extract(const char *source,int index,int n);

# 27 "C:\HT-XA\INCLUDE\stdarg.h"
typedef void * va_list[1];

# 27 "C:\HT-XA\INCLUDE\stdio.h"
extern int errno;

# 59
struct __prbuf
{
char * ptr;
void (* func)(char);
};

# 17 "C:\HT-XA\INCLUDE\conio.h"
extern int errno;


extern void init_uart(void);

extern char getch(void);
extern char getche(void);
extern void putch(char);
extern void ungetch(char);



extern int kbhit(void);

extern char * cgets(char *);
extern void cputs(const char *);

# 104 "C:\HT-XA\INCLUDE\stdio.h"
extern int cprintf(char *, ...);
#pragma  printf_check(cprintf)



extern int _doprnt(struct __prbuf *, const register char *, register va_list);

# 180
extern char * gets(char *);
extern int puts(const char *);
extern int scanf(const char *, ...);
extern int sscanf(const char *, const char *, ...);
extern int vprintf(const char *, va_list);
extern int vsprintf(char *, const char *, va_list);
extern int vscanf(const char *, va_list ap);
extern int vsscanf(const char *, const char *, va_list);

#pragma 	printf_check(printf)
#pragma 	printf_check(sprintf)


extern int sprintf(char *, const char *, ...);
extern int printf(const char *, ...);

# 133 "c:\apf9_new\include\logger.h"
typedef code const char cc;

# 140
long int LogAdd(const char *format,...);
int LogAttach(FILE *stream);
int LogClose(void);
long int LogEntry(cc *function_name,cc *format,...);
int LogOpen(const char *fname,char mode);
int LogOpenAuto(const char *basepath);
long int LogSize(void);
FILE *LogStream(void);


extern persistent long int MaxLogSize;


extern persistent unsigned int debugbits;


extern FILE *persistent logstream;

# 21 "c:\apf9_new\include\regex.h"
typedef long int regoff_t;
typedef struct {
long int re_magic;
size_t re_nsub;
const char *re_endp;
struct re_guts *re_g;
} regex_t;
typedef struct {
regoff_t rm_so;
regoff_t rm_eo;
} regmatch_t;



extern int regcomp(regex_t *, const char *, int);

# 66
extern size_t regerror(int, const regex_t *, char *, size_t);



extern int regexec(const regex_t *, const char *, size_t, regmatch_t [], int);

# 80
extern void regfree(regex_t *);

# 50 "c:\apf9_new\include\strtoul.h"
int atoi(const char *s);
long int atol(const char *s);
long int strtol(const char *str, char **endptr, int base);
unsigned long int strtoul(const char *str, char **endptr, int base);

# 30 "C:\HT-XA\INCLUDE\time.h"
extern int time_zone;

# 35
extern time_t time(time_t *);
extern int stime(time_t *);
extern char * asctime(struct tm *);
extern char * ctime(time_t *);
extern struct tm * gmtime(time_t *);
extern struct tm * localtime(time_t *);
extern time_t mktime(struct tm *);
extern size_t strftime(char *, size_t, const char *, const struct tm *);

# 78 "c:\apf9_new\include\ds2404.h"
extern const unsigned char Ds2404RtfMask;
extern const unsigned char Ds2404ItfMask;


int Ds2404Init(void);
int Ds2404RamTest(void);
int Ds2404Reset(void);
unsigned char Ds2404StatusByte(void);
time_t ialarm(void);
int IntervalAlarmCheck(void);
int IntervalAlarmDisable(void);
int IntervalAlarmEnable(void);
int IntervalAlarmGet(time_t *sec,unsigned char *tics);
int IntervalAlarmSet(time_t sec,unsigned char tics);
int IntervalTimerGet(time_t *sec,unsigned char *tics);
int IntervalTimerSet(time_t sec,unsigned char tics);
time_t itimer(void);
int RtcAlarmCheck(void);
int RtcAlarmDisable(void);
int RtcAlarmEnable(void);
int RtcAlarmGet(time_t *sec,unsigned char *tics);
int RtcAlarmSet(time_t sec,unsigned char tics);
int RtcGet(time_t *sec,unsigned char *tics);
int RtcSet(time_t sec,unsigned char tics);
int SetAlarm(time_t sec);
time_t time(time_t *sec);

# 182 "C:\APF9_NEW\SRC\CONFIG.C"
persistent struct MissionParameters mission;



const struct MissionParameters DefaultMission =
{
0,124,96,10,16,227,9,22,0,66,16,1,1000,2000,0,
6*(3600L),10*(86400L),9*(3600L),6*(3600L),6*(3600L),15*(60L),11*(3600L),-1,
1*(60L),"ATDT0012066163256","ATDT0012066859312","e=2.718",
"iridium"
};


const char config_path[] = "mission.cfg";


persistent char log_path[32];


const float dPdt=0.08;


const float MinN2ParkPressure=850;


static int ConfigSupervisor(struct MissionParameters *cfg);
static int fatal(const char *expr, const char *why);
static int warn(const char *expr, const char *why);


time_t itimer(void);
int MissionParametersWrite(struct MissionParameters *mission);
void PowerOff(time_t AlarmSec);
int RecoveryInit(void);
int fioFormat(void);
int Tc58v64Init(void);

# 481
int configure(struct MissionParameters *config, const char *fname)
{
static cc FuncName[] = "configure()";
int status=-1;
FILE *source=((void *)0);


if (!config)
{

static cc msg[]="Invalid configuration object.\n";


LogEntry(FuncName,msg);
}


else if (!fname)
{

static cc msg[]="Invalid configuration file.\n";


LogEntry(FuncName,msg);
}


else if (!(source=fopen(fname,"r")))
{

static cc format[]="Attempt to open \"%s\" failed.\n";


LogEntry(FuncName,format,fname);


status=0;
}

else
{


int i,k,len;
unsigned int crc1,crc0;
char *p,buf[(126)+2],configurator[(126)+2],parm[(63)+1],arg[(63)+1];
regex_t regex;
regmatch_t regs[(6)+1];
int errcode;
int RecoveryMode=0,Erase=0,FsCreate=0;
struct MissionParameters cfg;

# 539
const char *pattern = "^" "[ \t\r]*" "((" "([a-zA-Z0-9]+)" "[ \t\r]*" "\\((.*)\\)" ")" "[ \t\r]*" "(\\[(0x[0-9a-fA-F]{1,4})\\])?" ")" "[ \t\r]*" "$";


enum {ActivateRecoveryMode, AirBladderMaxP, AscentTimeOut, AtDialCmd, AltDialCmd,
BuoyancyNudge, CompensatorHyperRetraction, ConnectTimeOut, CpActivationP,
DeepProfileDescentTime, DeepProfilePistonPos, DeepProfilePressure, DownTime,
FlashErase, FlashCreate, FloatId, InitialBuoyancyNudge, MaxLogKb, ParkDescentTime,
ParkPistonPos, ParkPressure, PnPCycleLen, Pwd, TelemetryRetry, ToD, UpTime, User,
Verbosity, NVAR};


const char *parms[NVAR];


status=1;


cfg=*config;


parms[ActivateRecoveryMode] = "activaterecoverymode";
parms[AirBladderMaxP] = "airbladdermaxp";
parms[AscentTimeOut] = "ascenttimeout";
parms[AtDialCmd] = "atdialcmd";
parms[AltDialCmd] = "altdialcmd";
parms[BuoyancyNudge] = "buoyancynudge";
parms[CompensatorHyperRetraction] = "compensatorhyperretraction";
parms[ConnectTimeOut] = "connecttimeout";
parms[CpActivationP] = "cpactivationp";
parms[DeepProfileDescentTime] = "deepprofiledescenttime";
parms[DeepProfilePistonPos] = "deepprofilepistonpos";
parms[DeepProfilePressure] = "deepprofilepressure";
parms[DownTime] = "downtime";
parms[FlashErase] = "flasherase";
parms[FlashCreate] = "flashcreate";
parms[FloatId] = "floatid";
parms[InitialBuoyancyNudge] = "initialbuoyancynudge";
parms[MaxLogKb] = "maxlogkb";
parms[ParkDescentTime] = "parkdescenttime";
parms[ParkPistonPos] = "parkpistonpos";
parms[ParkPressure] = "parkpressure";
parms[PnPCycleLen] = "pnpcyclelen";
parms[Pwd] = "pwd";
parms[TelemetryRetry] = "telemetryretry";
parms[ToD] = "timeofday";
parms[UpTime] = "uptime";
parms[User] = "user";
parms[Verbosity] = "verbosity";


if(!(regcomp(&regex,pattern,0001|0010)==0)) {_fassert(589, "C:\APF9_NEW\SRC\CONFIG.C", "regcomp(&regex,pattern,0001|0010)==0");};


if(!((6)==regex.re_nsub)) {_fassert(592, "C:\APF9_NEW\SRC\CONFIG.C", "(6)==regex.re_nsub");};


if ((debugbits&(0x07))>=2 || (debugbits&(0x0100U)))
{

static cc format[]="Parsing configurators in \"%s\".\n";


LogEntry(FuncName,format,fname);
}


while (fgets(buf,(126)+2,source))
{

if ((len=strlen(buf))>(126))
{

static cc format[]="Line length exceeds %d bytes: %s\n";


LogEntry(FuncName,format,(126),buf);


status=0; continue;
}


if ((errcode=regexec(&regex,buf,regex.re_nsub+1,regs,0))==1)
{

int index = strspn(buf," \t\r\n");


if (index!=len && buf[index]!='#')
{

if ((debugbits&(0x07))>=2 || (debugbits&(0x0100U)))
{

static cc format[]="Syntax error: %s";


LogEntry(FuncName,format,buf);
}


status=0;
}

continue;
}


else if (errcode)
{

static cc format[]="Exception in regexec(): %s\n";


char errbuf[128]; regerror(errcode,&regex,errbuf,128);


LogEntry(FuncName,format,errbuf);


status=0;
}


else
{

strcpy(configurator,extract(buf,regs[1].rm_so+1,regs[1].rm_eo-regs[1].rm_so));


if ((debugbits&(0x07))>=2 || (debugbits&(0x0100U)))
{

static cc format[]="   %s ";


LogEntry(FuncName,format,configurator);
}


if ((regs[3].rm_eo-regs[3].rm_so)>(63))
{
LogAdd("[Configurator name exceeds %d bytes].\n",(63));


status=0; continue;
}


else strcpy(parm,extract(buf,regs[3].rm_so+1,regs[3].rm_eo-regs[3].rm_so));


if ((regs[4].rm_eo-regs[4].rm_so)>(63))
{
LogAdd("[Configurator argument exceeds %d bytes].\n",(63));


status=0; continue;
}


else strcpy(arg,extract(buf,regs[4].rm_so+1,regs[4].rm_eo-regs[4].rm_so));


p = extract(buf,regs[2].rm_so+1,regs[2].rm_eo-regs[2].rm_so);


crc0 = Crc16Bit((unsigned char *)p,regs[2].rm_eo-regs[2].rm_so);


if (regs[5].rm_so!=-1 && regs[5].rm_eo!=-1)
{

p = extract(buf,regs[6].rm_so+1,regs[6].rm_eo-regs[6].rm_so);


crc1 = strtoul(p,((void *)0),16);


if (crc0!=crc1)
{
if ((debugbits&(0x07))>=2 || (debugbits&(0x0100U)))
{

LogAdd("[CRC check failed: 0x%04X != 0x%04X].\n",crc0,crc1);
}


status=0; continue;
}
}


else if ((debugbits&(0x07))>=2 || (debugbits&(0x0100U))) LogAdd("[CRC=0x%04X] ",crc0);


for (i=regs[3].rm_so; i<regs[3].rm_eo; i++) {buf[i] = tolower(buf[i]);}


for (k=0; k<NVAR; k++)
{

if (!strncmp(parms[k],buf+regs[3].rm_so,strlen(parms[k]))) break;
}

switch (k)
{

case ActivateRecoveryMode:
{
RecoveryMode=1;


if ((debugbits&(0x07))>=2 || (debugbits&(0x0100U))) LogAdd("[ActivateRecoveryMode()].\n");

break;
}


case AirBladderMaxP:
{

cfg.MaxAirBladder=atoi(arg);

if ((debugbits&(0x07))>=2 || (debugbits&(0x0100U)))
{

LogAdd("[AirBladderMaxP(%d)].\n",cfg.MaxAirBladder);
}

break;
}


case AscentTimeOut:
{

cfg.TimeOutAscent=atol(arg)*(60L);

if ((debugbits&(0x07))>=2 || (debugbits&(0x0100U)))
{

LogAdd("[AscentTimeOut(%ld)].\n",cfg.TimeOutAscent/(60L));
}

break;
}


case AtDialCmd:
{

strncpy(cfg.at,arg,sizeof(cfg.at)-1);


if ((debugbits&(0x07))>=2 || (debugbits&(0x0100U))) LogAdd("[AtDialCmd(%s)].\n",cfg.at);

break;
}


case AltDialCmd:
{

strncpy(cfg.alt,arg,sizeof(cfg.alt)-1);


if ((debugbits&(0x07))>=2 || (debugbits&(0x0100U))) LogAdd("[AltDialCmd(%s)].\n",cfg.alt);

break;
}


case BuoyancyNudge:
{

cfg.PistonBuoyancyNudge=atoi(arg);

if ((debugbits&(0x07))>=2 || (debugbits&(0x0100U)))
{

LogAdd("[BuoyancyNudge(%d)].\n",cfg.PistonBuoyancyNudge);
}

break;
}


case CompensatorHyperRetraction:
{

cfg.PistonParkHyperRetraction=atoi(arg);

if ((debugbits&(0x07))>=2 || (debugbits&(0x0100U)))
{

LogAdd("[CompensatorHyperRetraction(%d)].\n",
cfg.PistonParkHyperRetraction);
}

break;
}


case ConnectTimeOut:
{

cfg.ConnectTimeOut=atol(arg);

if ((debugbits&(0x07))>=2 || (debugbits&(0x0100U)))
{

LogAdd("[ConnectTimeOut(%ld)].\n",cfg.ConnectTimeOut);
}

break;
}



case CpActivationP:
{
cfg.PressureCP = 0;


if ((debugbits&(0x07))>=2 || (debugbits&(0x0100U)))
{
LogAdd("[CpActivationP(%g)].\n",cfg.PressureCP);
}

break;
}


case DeepProfileDescentTime:
{

cfg.TimeDeepProfileDescent=atol(arg)*(60L);

if ((debugbits&(0x07))>=2 || (debugbits&(0x0100U)))
{

LogAdd("[DeepProfileDescentTime(%ld)].\n",
cfg.TimeDeepProfileDescent/(60L));
}

break;
}


case DeepProfilePistonPos:
{

cfg.PistonDeepProfilePosition=atoi(arg);

if ((debugbits&(0x07))>=2 || (debugbits&(0x0100U)))
{

LogAdd("[DeepProfilePistonPos(%d)].\n",
cfg.PistonDeepProfilePosition);
}

break;
}


case DeepProfilePressure:
{

cfg.PressureProfile=atof(arg);


if ((debugbits&(0x07))>=2 || (debugbits&(0x0100U)))
{
LogAdd("[ProfilePressure(%g)].\n",cfg.PressureProfile);
}

break;
}


case DownTime:
{

cfg.TimeDown=atol(arg)*(60L);

if ((debugbits&(0x07))>=2 || (debugbits&(0x0100U)))
{

LogAdd("[DownTime(%ld)].\n",cfg.TimeDown/(60L));
}

break;
}


case FlashErase:
{
Erase=1;


if ((debugbits&(0x07))>=2 || (debugbits&(0x0100U))) LogAdd("[FlashErase()].\n");

break;
}


case FlashCreate:
{
FsCreate=1;


if ((debugbits&(0x07))>=2 || (debugbits&(0x0100U))) LogAdd("[FlashCreate()].\n");

break;
}


case FloatId:
{

cfg.FloatId=atoi(arg);

if ((debugbits&(0x07))>=2 || (debugbits&(0x0100U)))
{

LogAdd("[FloatId(%d)].\n",cfg.FloatId);
}

break;
}


case InitialBuoyancyNudge:
{

cfg.PistonInitialBuoyancyNudge=atoi(arg);

if ((debugbits&(0x07))>=2 || (debugbits&(0x0100U)))
{

LogAdd("[InitialBuoyancyNudge(%d)].\n",
cfg.PistonInitialBuoyancyNudge);
}

break;
}


case ParkDescentTime:
{

cfg.TimeParkDescent=atol(arg)*(60L);

if ((debugbits&(0x07))>=2 || (debugbits&(0x0100U)))
{

LogAdd("[ParkDescentTime(%ld)].\n",cfg.TimeParkDescent/(60L));
}

break;
}


case ParkPistonPos:
{

cfg.PistonParkPosition=atoi(arg);

if ((debugbits&(0x07))>=2 || (debugbits&(0x0100U)))
{

LogAdd("[ParkPistonPos(%d)].\n",cfg.PistonParkPosition);
}

break;
}


case ParkPressure:
{

cfg.PressurePark=atof(arg);

if ((debugbits&(0x07))>=2 || (debugbits&(0x0100U)))
{

LogAdd("[ParkPressure(%g)].\n",cfg.PressurePark);
}

break;
}


case PnPCycleLen:
{

cfg.PnpCycleLength=atoi(arg);

if ((debugbits&(0x07))>=2 || (debugbits&(0x0100U)))
{

LogAdd("[PnpCycleLength(%d)].\n",cfg.PnpCycleLength);
}

break;
}


case Pwd:
{

strncpy(cfg.pwd,arg,sizeof(cfg.pwd)-1);


if ((debugbits&(0x07))>=2 || (debugbits&(0x0100U))) LogAdd("[Pwd(%s)].\n",cfg.pwd);

break;
}


case TelemetryRetry:
{

cfg.TimeTelemetryRetry=atol(arg)*(60L);

if ((debugbits&(0x07))>=2 || (debugbits&(0x0100U)))
{

LogAdd("[TelemetryRetry(%ld)].\n",cfg.TimeTelemetryRetry/(60L));
}

break;
}


case ToD:
{
long int tod=atol(arg);


cfg.ToD=(inRange(0,tod,1440)) ? (tod*(60L)) : -1;

if (!inRange(0,cfg.ToD,(86400L)))
{
LogAdd("Time-of-day specification disabled.\n");
}

else if ((debugbits&(0x07))>=2 || (debugbits&(0x0100U)))
{

LogAdd("[TimeOfDay(%ld)].\n",cfg.ToD/(60L));
}

break;
}


case UpTime:
{

cfg.TimeUp=atol(arg)*(60L);


if ((debugbits&(0x07))>=2 || (debugbits&(0x0100U))) LogAdd("[UpTime(%ld)].\n",cfg.TimeUp/(60L));

break;
}


case User:
{

strncpy(cfg.user,arg,sizeof(cfg.user)-1);


if ((debugbits&(0x07))>=2 || (debugbits&(0x0100U))) LogAdd("[User(%s)].\n",cfg.user);

break;
}


case Verbosity:
{

long int verbosity=strtoul(arg,((void *)0),16);


if (verbosity>=0 && (verbosity&(0x07))<=4 && verbosity<=65535)
{
if ((debugbits&(0x07))>=2 || (debugbits&(0x0100U)))
{

if (!verbosity) LogAdd("[Warning: terse mode enabled - "
"Verbosity(0x%04x)].\n",verbosity);


else LogAdd("[Verbosity(0x%04x)].\n",verbosity);
}


debugbits=verbosity;
}
else {LogAdd("[Ignoring invalid verbosity: 0x%04x].\n",verbosity);}

break;
}


case MaxLogKb:
{

int maxlogkb = atoi(arg);


if (maxlogkb>=5 && maxlogkb<=63)
{

MaxLogSize=maxlogkb*1024L;


if ((debugbits&(0x07))>=2 || (debugbits&(0x0100U))) LogAdd("[MaxLogKb(%d)].\n",maxlogkb);
}
else {LogAdd("[Ignoring invalid log size limit: %d Kbytes].\n",maxlogkb);}

break;
}

default:
{

if ((debugbits&(0x07))>=2 || (debugbits&(0x0100U))) LogAdd("[Unrecognized configurator].\n");


status=0;
}
}
}
}


fclose(source);


regfree(&regex);


if (status>0)
{
if ((debugbits&(0x07))>=2 || (debugbits&(0x0100U)))
{

static cc msg[]="Configuration CRCs and syntax OK.\n";


LogEntry(FuncName,msg);
}


if ((status=ConfigSupervisor(&cfg))>0)
{

if (config->crc != cfg.crc)
{

*config=cfg;


if (MissionParametersWrite(config)<=0)
{
static cc msg[]="Attempt to write mission "
"configuration to EEPROM failed.\n";
LogEntry(FuncName,msg);
}


else LogConfiguration(config,"Mission");
}
}
else
{

static cc msg[]="Configuration rejected by configuration supervisor.\n";
LogEntry(FuncName,msg);
}


if (FsCreate>0)
{
{static cc msg[]="Creating the FLASH file system.\n"; LogEntry(FuncName,msg);}


Tc58v64Init();

{static cc msg[]="FLASH file system created\n"; LogEntry(FuncName,msg);}
}


else if (Erase>0)
{

fioFormat();

{static cc msg[]="All files in FLASH file system erased\n"; LogEntry(FuncName,msg);}
}


if (RecoveryMode>0)
{
time_t SeqTime=itimer(),alarm=ialarm();


static cc format[]="Recovery mode activated. [itimer:%ld, alarm:%ld]\n";


RecoveryInit(); LogEntry(FuncName,format,SeqTime,alarm);


SeqTime=itimer() + (6L);


alarm = SeqTime - SeqTime%cfg.TimeTelemetryRetry + cfg.TimeTelemetryRetry;


PowerOff(alarm);
}
}
}

return status;
}

# 1284
static int ConfigSupervisor(struct MissionParameters *cfg)
{
static cc FuncName[]="ConfigSupervisor()";
int status=1;

# 1296
cfg->crc = Crc16Bit((unsigned char *)(&cfg), sizeof(cfg)-sizeof(cfg->crc));


if (((inCRange( 0, (debugbits&(0x07)), 5)) ? 0 : fatal("inCRange( 0, debuglevel, 5)",((void *)0)))) status=0;
if (((inCRange( 240, cfg->MaxAirBladder, 1)) ? 0 : fatal("inCRange( 240, cfg->MaxAirBladder, 1)",((void *)0)))) status=0;
if (((inCRange( 254, cfg->PistonBuoyancyNudge, 1)) ? 0 : fatal("inCRange( 254, cfg->PistonBuoyancyNudge, 1)",((void *)0)))) status=0;
if (((inCRange( 254, cfg->PistonDeepProfilePosition, 1)) ? 0 : fatal("inCRange( 254, cfg->PistonDeepProfilePosition, 1)",((void *)0)))) status=0;
if (((inCRange( 254, cfg->PistonInitialBuoyancyNudge, 1)) ? 0 : fatal("inCRange( 254, cfg->PistonInitialBuoyancyNudge, 1)",((void *)0)))) status=0;
if (((inCRange( 254, cfg->PistonParkHyperRetraction, 0)) ? 0 : fatal("inCRange( 254, cfg->PistonParkHyperRetraction, 0)",((void *)0)))) status=0;
if (((inCRange( 254, cfg->PistonParkPosition, 1)) ? 0 : fatal("inCRange( 254, cfg->PistonParkPosition, 1)",((void *)0)))) status=0;
if (((inCRange( 254, cfg->PnpCycleLength, 1)) ? 0 : fatal("inCRange( 254, cfg->PnpCycleLength, 1)",((void *)0)))) status=0;
if (((inCRange( 2000, cfg->PressurePark, 0)) ? 0 : fatal("inCRange( 2000, cfg->PressurePark, 0)",((void *)0)))) status=0;
if (((inCRange( 2000, cfg->PressureProfile, 0)) ? 0 : fatal("inCRange( 2000, cfg->PressureProfile, 0)",((void *)0)))) status=0;
if (((inCRange( 8*(3600L), cfg->TimeDeepProfileDescent, 0)) ? 0 : fatal("inCRange( 8*Hour, cfg->TimeDeepProfileDescent, 0)",((void *)0)))) status=0;
if (((inRange( 30*(86400L), cfg->TimeDown, (60L))) ? 0 : fatal("inRange( 30*Day, cfg->TimeDown, Min)",((void *)0)))) status=0;
if (((inCRange(10*(3600L), cfg->TimeOutAscent, (60L))) ? 0 : fatal("inCRange(10*Hour, cfg->TimeOutAscent, Min)",((void *)0)))) status=0;
if (((inRange( 8*(3600L), cfg->TimeParkDescent, 0)) ? 0 : fatal("inRange( 8*Hour, cfg->TimeParkDescent, 0)",((void *)0)))) status=0;
if (((inCRange( 6*(3600L), cfg->TimeTelemetryRetry, (60L))) ? 0 : fatal("inCRange( 6*Hour, cfg->TimeTelemetryRetry, Min)",((void *)0)))) status=0;
if (((inRange( 24*(3600L), cfg->TimeUp, (60L))) ? 0 : fatal("inRange( 24*Hour, cfg->TimeUp, Min)",((void *)0)))) status=0;
if (((inCRange( 300, cfg->ConnectTimeOut, 30)) ? 0 : fatal("inCRange( 300, cfg->ConnectTimeOut, 30)",((void *)0)))) status=0;




if (((cfg->TimeDown > cfg->TimeParkDescent+cfg->TimeDeepProfileDescent) ? 0 : fatal("cfg->TimeDown > cfg->TimeParkDescent+cfg->TimeDeepProfileDescent",((void *)0)))) status=0;


if (((cfg->TimeUp > cfg->TimeOutAscent) ? 0 : fatal("cfg->TimeUp > cfg->TimeOutAscent",((void *)0)))) status=0;


if (((cfg->TimeUp >= (cfg->PressureProfile/dPdt) + 2*(3600L)) ? 0 : fatal("cfg->TimeUp >= (cfg->PressureProfile/dPdt) + 2*Hour",((void *)0)))) status=0;


if (((cfg->TimeUp >= (cfg->PressurePark/dPdt) + 2*(3600L)) ? 0 : fatal("cfg->TimeUp >= (cfg->PressurePark/dPdt) + 2*Hour",((void *)0)))) status=0;


if (((cfg->PressureProfile >= cfg->PressurePark) ? 0 : fatal("cfg->PressureProfile >= cfg->PressurePark",((void *)0)))) status=0;


if (((!strncmp(cfg->at,"AT",2)) ? 0 : fatal("!strncmp(cfg->at,\"AT\",2)",((void *)0)))) status=0;
if (((!strncmp(cfg->alt,"AT",2)) ? 0 : fatal("!strncmp(cfg->alt,\"AT\",2)",((void *)0)))) status=0;




((cfg->TimeOutAscent >= (cfg->PressureProfile/dPdt) + 1*(3600L)) ? 0 : warn("cfg->TimeOutAscent >= (cfg->PressureProfile/dPdt) + 1*Hour",((void *)0)));


((cfg->TimeOutAscent >= (cfg->PressurePark/dPdt) + 1*(3600L)) ? 0 : warn("cfg->TimeOutAscent >= (cfg->PressurePark/dPdt) + 1*Hour",((void *)0)));


((cfg->TimeUp >= cfg->TimeOutAscent + 2*(3600L)) ? 0 : warn("cfg->TimeUp >= cfg->TimeOutAscent + 2*Hour",((void *)0)));


((cfg->TimeParkDescent >= cfg->PressurePark/dPdt) ? 0 : warn("cfg->TimeParkDescent >= cfg->PressurePark/dPdt",((void *)0)));


((cfg->TimeDeepProfileDescent >= (cfg->PressureProfile-cfg->PressurePark)/dPdt) ? 0 : warn("cfg->TimeDeepProfileDescent >= (cfg->PressureProfile-cfg->PressurePark)/dPdt",((void *)0)));


((cfg->TimeDown > cfg->TimeDeepProfileDescent + cfg->TimeParkDescent + 2*(3600L)) ? 0 : warn("cfg->TimeDown > cfg->TimeDeepProfileDescent + cfg->TimeParkDescent + 2*Hour",((void *)0)));


((cfg->TimeParkDescent <= 1.5*cfg->PressurePark/dPdt + 1*(3600L)) ? 0 : warn("cfg->TimeParkDescent <= 1.5*cfg->PressurePark/dPdt + 1*Hour",((void *)0)));


((cfg->TimeDeepProfileDescent <= 1.5*(cfg->PressureProfile-cfg->PressurePark)/dPdt + 1*(3600L)) ? 0 : warn("cfg->TimeDeepProfileDescent <= 1.5*(cfg->PressureProfile-cfg->PressurePark)/dPdt + 1*Hour",((void *)0)));


((cfg->PistonDeepProfilePosition <= cfg->PistonParkPosition) ? 0 : warn("cfg->PistonDeepProfilePosition <= cfg->PistonParkPosition",((void *)0)));


if (cfg->PistonParkHyperRetraction) ((cfg->PressurePark >= MinN2ParkPressure) ? 0 : warn("cfg->PressurePark >= MinN2ParkPressure",((void *)0)));


((inCRange(120,cfg->MaxAirBladder,128)) ? 0 : warn("inCRange(120,cfg->MaxAirBladder,128)",((void *)0)));

if (status>0)
{
static cc msg[]="Configuration accepted.\n"; LogEntry(FuncName,msg);


cfg->crc = Crc16Bit((unsigned char *)(cfg),sizeof(*cfg)-sizeof(cfg->crc));
}
else {static cc msg[]="Configuration rejected.\n"; LogEntry(FuncName,msg);}

return status;
}

# 1392
static int warn(const char *expr, const char *why)
{
static cc FuncName[]="warn()";

if (!expr)
{
static cc msg[]="NULL function argument.\n";

LogEntry(FuncName,msg);
}

else
{
static cc FuncName[]="ConfigSupervisor()";
static cc format[]="Sanity check violated: %s\n";
LogEntry(FuncName,format,expr);

if (why && *why) {static cc format[]="  (%s)\n"; LogEntry(FuncName,format,why);}
}

return 1;
}

# 1422
static int fatal(const char *expr, const char *why)
{
static cc FuncName[]="warn()";

if (!expr)
{
static cc msg[]="NULL function argument.\n";

LogEntry(FuncName,msg);
}
else
{
static cc FuncName[]="ConfigSupervisor()";
static cc format[]="Constraint violated: %s\n";

LogEntry(FuncName,format,expr);

if (why && *why) {static cc format[]="  (%s)\n"; LogEntry(FuncName,format,why);}
}

return 1;
}

# 1456
int inCRange(double a,double x,double b)
{
return ( ((x-a)*(x-b)<=0) ? 1 : 0);
}

# 1471
int inRange(double a,double x,double b)
{
return ( ((x-a)*(x-b)<=0 && x!=b) ? 1 : 0);
}




int LogConfiguration(const struct MissionParameters *config,const char *id)
{
static cc FuncName[] = "LogConfiguration()";
int status=-1;


if (!config)
{

static cc msg[]="NULL configuration.\n";


LogEntry(FuncName,msg);
}


else if (!id)
{

static cc msg[]="NULL configuration id.\n";


LogEntry(FuncName,msg);
}

else
{
static cc cfg[]="%s configuration for Apf9i FwRev %06lx:\n"; static cc indent[]="   ";


LogEntry(FuncName,cfg,id,FwRev);
LogEntry(FuncName,indent); LogAdd("AscentTimeOut(%ld) [min]\n",config->TimeOutAscent/(60L));
LogEntry(FuncName,indent); LogAdd("AtDialCmd(%s) [primary]\n",config->at);
LogEntry(FuncName,indent); LogAdd("AtDialCmd(%s) [alternate]\n",config->alt);
LogEntry(FuncName,indent); LogAdd("BuoyancyNudge(%u) [count]\n",config->PistonBuoyancyNudge);
LogEntry(FuncName,indent); LogAdd("BuoyancyNudgeInitial(%u) [count]\n",config->PistonInitialBuoyancyNudge);
LogEntry(FuncName,indent); LogAdd("ConnectTimeOut(%ld) [sec]\n",config->ConnectTimeOut);
LogEntry(FuncName,indent); LogAdd("CpActivationP(%g) [dbar]\n",config->PressureCP);
LogEntry(FuncName,indent); LogAdd("DeepProfileDescentTime(%ld) [min]\n",config->TimeDeepProfileDescent/(60L));
LogEntry(FuncName,indent); LogAdd("DeepProfilePistonPos(%d) [count]\n",config->PistonDeepProfilePosition);
LogEntry(FuncName,indent); LogAdd("DeepProfilePressure(%g) [dbar]\n",config->PressureProfile);
LogEntry(FuncName,indent); LogAdd("CompensatorHyperRetraction(%d) [count]\n",config->PistonParkHyperRetraction);
LogEntry(FuncName,indent); LogAdd("DownTime(%ld) [min]\n",config->TimeDown/(60L));
LogEntry(FuncName,indent); LogAdd("FloatId(%04u)\n",config->FloatId);
LogEntry(FuncName,indent); LogAdd("FullExtension(%u) [count]\n",config->PistonFullExtension);
LogEntry(FuncName,indent); LogAdd("FullRetraction(%u) [count]\n",config->PistonFullRetraction);
LogEntry(FuncName,indent); LogAdd("MaxAirBladder(%u) [count]\n",config->MaxAirBladder);
LogEntry(FuncName,indent); LogAdd("MaxLogKb(%ld) [KByte]\n",MaxLogSize/1024);
LogEntry(FuncName,indent); LogAdd("MissionPrelude(%ld) [min]\n",config->TimePrelude/(60L));
LogEntry(FuncName,indent); LogAdd("OkVacuum(%u) [count]\n",config->OkVacuumCount);
LogEntry(FuncName,indent); LogAdd("ParkDescentTime(%ld) [min]\n",config->TimeParkDescent/(60L));
LogEntry(FuncName,indent); LogAdd("ParkPistonPos(%d) [count]\n",config->PistonParkPosition);
LogEntry(FuncName,indent); LogAdd("ParkPressure(%g) [dbar]\n",config->PressurePark);
LogEntry(FuncName,indent); LogAdd("PnPCycleLen(%d)\n",config->PnpCycleLength);
LogEntry(FuncName,indent); LogAdd("Pwd(0x%04x)\n",
Crc16Bit((const unsigned char *)config->pwd,strlen(config->pwd)));
LogEntry(FuncName,indent); LogAdd("TelemetryRetry(%ld) [min]\n",config->TimeTelemetryRetry/(60L));

LogEntry(FuncName,indent); if (inRange(0,config->ToD,(86400L))) LogAdd("TimeOfDay(%ld) [min]\n",config->ToD/(60L));
else LogAdd("TimeOfDay(DISABLED) [min]\n");

LogEntry(FuncName,indent); LogAdd("UpTime(%ld) [min]\n",config->TimeUp/(60L));
LogEntry(FuncName,indent); LogAdd("User(%s)\n",config->user);
LogEntry(FuncName,indent); LogAdd("Verbosity(%d)\n",(debugbits&(0x07)));
LogEntry(FuncName,indent); LogAdd("DebugBits(0x%04x)\n",debugbits);


status=1;
}

return status;
}
